#!/usr/bin/env node

const { CLICommands, nicePrint, tryTask, execSync, table, newLine } = require("@solid-js/cli")
const path = require("path")
const { browsePackages, targetPackagesFromCli } = require( "./utils/cli-utils" );
const { File, Directory } = require("@solid-js/files")
const zlib = require( "zlib" );
const fs = require( "fs" );
const chalk = require("chalk")
const { defaultTerserOptions, defaultFormats, replaceImportsRegex } = require( "./utils/defaults" );
const { naiveHumanFileSize, filterDuplicates } = require( "./utils/common" );
const { buildPackage } = require( "./tsbundle" );

// -----------------------------------------------------------------------------

/**
 * INSPIRATION & RESOURCES
 * - microbundle : https://github.com/developit/microbundle
 * - enabling modern js on npm : https://jasonformat.com/enabling-modern-js-on-npm/
 * - tsconfig lib : https://www.typescriptlang.org/tsconfig#lib
 * - tsconfig module : https://www.typescriptlang.org/tsconfig#module
 */

/**
 * SOUCIS :
 * - Browser : Terser à l'air d'inclure dans le désordre + il s'en fout des imports export
 * 				et il les réinclus ce débile.
 * 		SOLUTION : Faire un outFile sans modules en es2017 et terser ça ensuite !
 * IMPACTS :
 * - Changer la conf
 * 		{
 * 		 	"commonjs" : "es2017" | false,
 * 		 	"module" : "es2020" | false,
 * 		 	"browser" : "es2017" | false -> + ça min derrière avec terser
 * 		}
 *
 * -> C'est moins flexible mais on contrôle mieux les effets de bord
 */

/**
 * -- MODULE FORMATS --
 *
 * CJS - Common js
 * - Legacy NodeJS module format
 * - require and module.exports functions
 *
 * MJS - Module JS
 * - Modern NodeJS and Browser format
 * - import and export keywords
 *
 * UMD - Universal Module Definition
 * - Multiple system compatible format, mainly for legacy browsers and node.
 * - Compatible with AMD, CommonJS, define / require / etc
 */

/**
 * ES5 - Legacy browsers and node
 * ⚠️ Can prepend Class and Promise helpers at top of file !
 * 🚫 Class and extends keywords
 * 🚫 Tagged literal strings
 * 🚫 Native promise
 * 🚫 Native spread
 * 🚫 Nullish coalescing operator
 *
 * ES2015
 * ⚠️ Can prepend Promise helpers at top of file !
 * 👍 Class and extends keywords
 * 👍 Tagged literal strings
 * 🚫 Native promise
 * 🚫 Native spread
 * 🚫 Nullish coalescing operator
 *
 * ES2017
 * 👍 Class and extends keywords
 * 👍 Tagged literal strings
 * 👍 Native promise
 * 🚫 Native spread
 * 🚫 Nullish coalescing operator
 *
 * ES2022
 * 👍 Class and extends keywords
 * 👍 Tagged literal strings
 * 👍 Native promise
 * 👍 Native spread
 * 👍 Nullish coalescing operator
 */


/**
 * TODO
 * - Node abstract version (not cli) should return an array of transformed files
 * 		- Then cli should convert it to cli table with human file sizes
 * 	 	- cli table shows wrong files. It should be clearer with input -> output(s)`
 * - Refacto all this
 */

// TODO : Move to common/builder.js #refacto a bit more
async function buildPackageOld ( packageConfig, progressHandler = function () {}, forceFormats = [] ) {
	// TODO : forceFormats which anihilate defaultFormats and format reading from package.json



	// // Clean output directory
	// const directory = new Directory( distPath )
	// await directory.clean();
	// Size report output
	let outputReports = []
	progressHandler(current, total)
	// Remember all dist paths
	const distPaths = []
	// Browse package config files to compile
	for ( const currentConfig of  files ) {
		// Target config and dist path
		const distPath = path.join( packageRoot, currentConfig.output )
		progressHandler(++current, total, 'preparing')
		// Browse all formats to compile to
		for ( let i in currentConfig.formats ) {
			const format = currentConfig.formats[ i ]

			// console.log( Object.keys( changed ) );

			// console.log( baseNames );

			// No file were output by tsc
			if ( Object.values(changed).length === 0 )
				throw new Error(`Error, no file were generated by tsc for ${rootFilePath} with format ${format}`)

			// Target main generated file, without extension
			const parsed = path.parse( rootFilePath )
			const mainFilePathWithoutExtension = path.join(outDirPath, parsed.name)

			// Messaged shown after progress bar
			const afterMessage = `${module}@${target} ➡ ${ path.relative(packageRoot, mainFilePathWithoutExtension) }.js`
			// Locally scoped helper to add an exported report for a specific file
			function addFileReport (source, destination, gzip) {
				const relativeFileName = path.relative(packageRoot, source)
				const report = [
					relativeFileName, module, target,
					chalk.cyan( naiveHumanFileSize( fs.statSync( destination ).size ) )
				]
				// Add gzipped size to output
				if (gzip) {
					const gzip = zlib.gzipSync( fs.readFileSync( destination ) )
					report.push( chalk.cyan.bold( naiveHumanFileSize( gzip.length ) ) )
				}
				else
					report.push("-")
				outputReports.push( report )
			}
			// If we need to bundle and minify this format
			if ( minify ) {
				progressHandler( current + .5, total, afterMessage )


				const browserifyCommand = [
					targetBin('browserify'),
					mainFilePathWithoutExtension
				].join(" ")
				process.exit();

				// Generated minified file from multiple files and mark it as "compressed"
				// We do it that way so it's easy to separate terser source and output files
				const destFilePath = `${mainFilePathWithoutExtension}.${format}.compressed`
				const terserCommand = [
					targetBin('terser'),
					...defaultTerserOptions,
					// One output
					`-o ${ destFilePath }`,
					// Multiple inputs
					`-- ${ Object.values( changed ).join(' ') }`
				].join(" ")
				// Execute terser command
				// FIXME : Catch errors, do it async ?
				execSync( terserCommand, 3 );
				addFileReport( `${mainFilePathWithoutExtension}.${format}`, destFilePath, true )
				// Delete terser source files
				Object.values( changed ).map( p => fs.unlinkSync(p) )
				// Mark output as to rename now we removed source files
				recursiveChangeExtension( distPath, `.compressed`, '.torename', true );
			}
			// Multiple outputs
			else {
				// Browse every generated files to add to the report
				Object.keys( changed ).map( key => addFileReport( key, changed[key], false ) )
			}
			// Update progress
			progressHandler( ++current, total, afterMessage )
		}
		// Register this dist path to rename all files later
		distPaths.push( distPath )
		// Remove tsconfig file
		await tsconfigTemp.delete()
	}
	// Rename all files now
	// If we do it in the loop, we may rename files incorrectly
	distPaths
		.filter( filterDuplicates )
		.map( p => recursiveChangeExtension( p, '.torename', '' ) )
	return outputReports
}

// ----------------------------------------------------------------------------- COMMANDS

// TODO : Move it to @zouloux/node-toolbox
function showIntroMessage () {
	const tsbundlePackage = require(path.normalize(__dirname+"/../package.json"))
	nicePrint(`{w}Using {w/b}${tsbundlePackage.name}{d} {w}v${tsbundlePackage.version}`)
}

// Get packages list and configs before any action
let packages = {}
CLICommands.before((cliOptions, cliArguments) => {
	showIntroMessage();
	packages = targetPackagesFromCli( cliOptions, cliArguments )
})

CLICommands.add("build", async () => {
	// Browse all packages from cli arguments
	await browsePackages( packages, async (key, packageConfig) => {
		// console.log( packageConfig.files );
		await buildPackage( packageConfig )

		// // Build this packages
		// let output = []
		// await tryTask(`Building ${key}`, async task => {
		// 	output.push( await buildPackage( config, task.progress ) )
		// })
		// // Show report
		// newLine()
		// output = [
		// 	["File", "Module", "Target", "Size", "GZip"],
		// 	...output.flat()
		// ]
		// table(output, true, [20], '    ')
		// newLine()
	})

})
CLICommands.add("test", () => {
	// TODO : Build only needed output and execute `npm run test` for specific package
})
CLICommands.add("clean", () => {
	// TODO : Extract clean function and execute it only here
})
CLICommands.add("publish", () => {
	// TODO : Inspire from solid-js
	// TODO : Run test (with minimal building)
	// TODO : If test passing : Ask for increment and message
	// TODO : Then build everything (should pass because of test passing
	// TODO : Then git push + npm publish
})

// Start CLI command listening
CLICommands.start( (commandName, error, cliArguments, cliOptions, results) => {
	// console.log({commandName, error, cliArguments, cliOptions, results})
	error && nicePrint( `{b/r}${error.message}`, { code: 1 })
});